# Smart\_Calendar



# Участники проекта

Баженов Савелий, Симонов Константин, Третьяк Антон

#### Определение проблемы



В компаниях постоянно есть общие события и дедлайны, которые нельзя пропустить, поэтому нужно вести календарь этих событий, однако в таком случае только один пользователь может редактировать его и просматривать, а с остальными ему не удобно делится. Это приводит к тому что компания не может быстро ввести информацию в календарь если этого администратора нет на месте. Компания не может быстро отреагировать на изменения и уведомить своих сотрудников, что может создать огромные проблемы.



#### Выработка требований - пользовательские сценарии

&nbsp;	Создать свой личный календарь

&nbsp;	Дать право доступа и роль другому человеку

&nbsp;	Возможность создавать и редактировать повторяющиеся события

&nbsp;

##### 1\. *Регистрация нового пользователя*

&nbsp;	Я - новый пользователь, я хочу зарегистрироваться с уникальным логином и паролем, чтобы получить доступ к своему личному календарю.

##### 2\. *Вход в систему*

&nbsp;	Когда я уже зарегистрированный пользователь, я хочу войти в систему с помощью своего логина и пароля, чтобы войти в свой календарь.

##### 3\. *Добавление участников в календарь*

&nbsp;	Когда у меня уже есть свой календарь, я хочу добавить участников по их email и указать их роль в календаре.

##### 4\. *Добавление ролей участников*

&nbsp;	Владелец должен мочь добавлять модераторов на читателей, а модератор должен мочь добавлять только читателей.

##### 5\. *Изменение ролей участников*

&nbsp;	Владелец должен уметь изменять роли пользователей с модераторов на читателей и наоборот.

##### 6\. *Безопасный выход пользователя*

&nbsp;	Когда человек заканчивает работу в календаре, он хочет безопасно выйти из системы, чтобы защитить свою учетную запись.



#### Архитектура проекта



##### &nbsp;*Нагрузка на сервис*

###### &nbsp;1) Соотношение R/W нагрузки 80/20

&nbsp;	Основная нагрузка на чтение - это проверка событий, роли участников и их количество

&nbsp;	Основная нагрузка на запись - это запись событий в календарь

###### &nbsp;2) Объемы трафика

&nbsp;	Загрузка календаря
	10 000 пользователей и 20 загрузок в день = 200 000 запросов/день
	Возьмем в среднем 5 изменений событий в день на пользователя = 50 000 запросов/день
	Служебные запросы тоже возьмем 50 000 запросов/день
	Итого 300 000 запросов/день
	Загрузка календаря 200 000 \* 0.3 КБ
	Создание/обновление событий 50 000 \* 1 КБ
	Служебные запросы 50 000 \* 0.3 КБ
	Запросы: 125 МБ / день
	Ответы же вышли больше
	1.27 ГБ / день
	ИТОГО: 1.4 ГБ / день

###### &nbsp;3) Объемы дисковой системы

&nbsp; 	При расчёте на 10 000 пользователей и средней пользовательской активности (2 календаря на пользователя, 20 событий на календарь, из них 30% 	повторяющихся) объём данных составляет порядка 12 ГБ в год. Основной вклад в рост дисковой системы вносит таблица materialized occurrences, 	содержащая конкретные появления повторяющихся событий.
	Пользователь — 0.3 КБ

&nbsp;	
	**Оценки памяти для хранения одного объекта**
	

&nbsp;	Пользователь — 0.3 КБ



&nbsp;	Календарь — 0.4 КБ

&nbsp;	Событие (event) — 0.8 КБ

&nbsp;	Задача (task) — 0.7 КБ

&nbsp;	Occurrence (материализованное повторение) — 0.5 КБ

&nbsp;	Служебная запись (outbox\_job) — 0.5 КБ	
	



&nbsp;	Вводные данные
	10 000 пользователей всего

&nbsp;	В среднем:

&nbsp;	2 календаря на пользователя

&nbsp;	20 событий на календарь

&nbsp;	30% событий — повторяющиеся

&nbsp;	Средняя частота повторения:

&nbsp;	1 occurrence в 2 дня



&nbsp;	Предположим рост 20 новых пользователей в день (6 КБ / день)
	Календари (16 КБ / день)
	События (640 КБ / день)
	Повторяющиеся события → occurrences (60 КБ / день)
	Задачи (560 КБ / день)
	Служебные данные (200 КБ / день)

	ИТОГО: 1.5 МБ / день или 550 МБ / год. За 5 лет 2750 МБ

#### 

#### **Внешние акторы и системы**


*Container Diagram (Уровень 1)*
---



Система взаимодействует со следующими внешними акторами:

&nbsp;	Пользователи Используют веб- или десктоп-клиент для просмотра и управления своими календарями, событиями и задачами.

&nbsp;	Клиентское приложение (Frontend) Web / Desktop UI, взаимодействующее с системой через HTTP REST API, отправляющее запросы на чтение и изменение данных календаря и получающее ответы в формате JSON.

&nbsp;	Система аутентификации (внешняя или встроенная)	обеспечивает идентификацию пользователя и передачу user context (например, user\_id) в Calendar Service.


Calendar Service взаимодействует с конечными пользователями через клиентские приложения, предоставляя REST API для работы с календарями, событиями и задачами. Система получает аутентифицированные запросы от фронтенда, обрабатывает бизнес-логику и сохраняет данные в хранилище. Внешние акторы не имеют прямого доступа к базе данных, все операции проходят через серверное API.	


Container Diagram (Уровень 2)
---


Calendar API Server. Обрабатывает HTTP REST API запросы, реализует бизнес-логику календарей, управляет событиями, задачами и повторениями, инициирует materialization повторяющихся событий, публикует фоновые задачи в outbox.
Основные функции: CRUD операций для календарей, событий и задач, генерация occurrences для recurring-событий, проверка прав доступа, валидация входных данных.

PostgreSQL: хранение пользователей и календарей, хранение событий и задач, хранение materialized occurrences, хранение служебных таблиц (outbox\_jobs).



Outbox / Background Worker (фоновые задачи внутри сервиса). асинхронная обработка тяжёлых операций, materialization повторяющихся событий, пересчёт occurrences при изменении правил повторения, очистка устаревших данных.



Redis: кэширование часто запрашиваемых календарей, хранение временных данных, снижение нагрузки на PostgreSQL при read-heavy нагрузке.


*Внешние системы*
---



Client Applications (Web / Desktop)

Используют REST API Calendar Service по HTTP/JSON.



###### *Связи между контейнерами*



Client → Calendar API Server

HTTP REST API (JSON)



Calendar API Server → PostgreSQL

SQL запросы (чтение и запись данных)



Calendar API Server → Redis

Кэширование и чтение временных данных



Calendar API Server → Outbox Worker

Асинхронная обработка задач


**Контракты API**
---


Получение списка календарей пользователя
GET /api/v1/calendars



Получение событий календаря за период
GET /api/v1/calendars/{calendar\_id}/events



Создание события
POST /api/v1/calendars/{calendar\_id}/events



Обновление события
PUT /api/v1/events/{event\_id}



Удаление события
DELETE /api/v1/events/{event\_id}



Получение задач пользователя
GET /api/v1/tasks



#### **Нефункциональные требования**


	*Требования к времени отклика*
---

&nbsp;	Чтение календаря ≤ 200 мс
	Получение списка событий ≤ 300 мс
	Создание / обновление события ≤ 400 мс

&nbsp;	Удаление события ≤ 300 мс



###### &nbsp;	*Пропускная способность*

&nbsp;	Средняя нагрузка: ~1 000 RPS

&nbsp;	Пиковая нагрузка: до 3 000 RPS

&nbsp;	Система должна обрабатывать пиковую нагрузку без деградации SLA.



###### &nbsp;	*Надёжность и отказоустойчивость*

&nbsp;	Сервис должен быть доступен 99.9% времени

&nbsp;	Отказ Redis не должен приводить к недоступности сервиса

&nbsp;	Все критические данные хранятся в PostgreSQL



###### &nbsp;	*Масштабируемость*

&nbsp;	Горизонтальное масштабирование API Server

&nbsp;	Stateless API → масштабируется за load balancer

&nbsp;	Возможность вынесения background worker в отдельный контейнер



###### &nbsp;	*Консистентность данных*

&nbsp;	PostgreSQL используется как single source of truth

&nbsp;	ACID-гарантии для операций записи

&nbsp;	Асинхронные операции (occurrences) не блокируют HTTP-запросы



###### &nbsp;	*Безопасность*

&nbsp;	Аутентификация пользователя на уровне API

&nbsp;	Проверка прав доступа к календарям

&nbsp;	Валидация входных данных

&nbsp;	Защита от перегрузки (rate limiting)



### **Схема БД**


![BD](/Pictures/BD.png)


### **Почему схема выдерживает нефункциональные требования**

###### *Время отклика* (чтение календаря) ≤ 300 мс


*Пропускная способность*
---

Основная нагрузка — чтение. Чтения работают по одной таблице и одному диапазонному индексу
PostgreSQL эффективно обслуживает тысячи RPS на таких запросах, особенно при hot-data cache в RAM.



###### *Масштабируемость*

API stateless → масштабируется горизонтально

PostgreSQL:

read-replicas для масштабирования чтения

партиционирование occurrences по start\_ts при росте
	

*Изоляция тяжёлых операций*
Materialization повторений вынесена в outbox\_jobs
---

HTTP-запросы не блокируются и не зависят от фоновых операций



###### *Управляемый рост данных*

occurrences растёт линейно

Возможно ограничение горизонта (например, +6 месяцев) или очистка старых occurrences, архивирование


#### Схема масштабирования сервиса при росте нагрузки в 10 раз



##### Горизонтальное масштабирование



###### Calendar API Server

Запуск нескольких инстансов Calendar API Server за load balancer (nginx / HAProxy / cloud LB)

Stateless-архитектура сервиса позволяет масштабировать API горизонтально без синхронизации состояния между инстансами

Каждый инстанс обслуживает ограниченное количество RPS, нагрузка равномерно распределяется балансировщиком

Использование keep-alive соединений и асинхронной обработки запросов для снижения latency



###### Background Workers (outbox)

Выделение отдельного пула background worker’ов

Масштабирование количества воркеров независимо от API Server

Асинхронная обработка:

&nbsp;	materialization повторяющихся событий;

&nbsp;	пересчёт occurrences при изменениях;

&nbsp;	очистка устаревших данных.



###### PostgreSQL

Настройка репликации:

1 primary (master) — операции записи

2–4 read replicas — операции чтения

Read-запросы (~80% нагрузки) направляются на read replicas

Write-запросы (~20% нагрузки) выполняются на primary

Партиционирование таблицы occurrences по времени (месяц / квартал) для эффективной работы с большими объёмами данных

Использование connection pooling (PgBouncer) для оптимального использования соединений



###### Redis

Использование Redis для:

кэширования календарей за период;

хранения часто запрашиваемых данных;

снижения нагрузки на PostgreSQL при read-heavy нагрузке.

При росте нагрузки:

переход на Redis Cluster для горизонтального масштабирования;

использование Redis Sentinel для обеспечения высокой доступности и failover.



##### Вертикальное масштабирование



Увеличение ресурсов (CPU, RAM) контейнеров Calendar API Server для обработки большего количества одновременных запросов

Увеличение ресурсов PostgreSQL:

больше RAM для page cache и индексов;

больше CPU для выполнения параллельных запросов

Вертикальное масштабирование используется как дополнительная мера до достижения пределов горизонтального масштабирования



###### Оптимизация

Кэширование

Кэширование часто запрашиваемых данных (календари за период, список событий) в Redis

Снижение количества обращений к БД на 50–70%



###### Асинхронная обработка

Тяжёлые операции (materialization повторений, пересчёт occurrences) выполняются асинхронно через outbox-паттерн

HTTP-запросы остаются быстрыми и не блокируются


#### UNIT тестирование

Тесты запускаются с помощью этой команды

ctest --output-on-failure



Интеграционное тестирование

Запускается той же командой что и UNIT тестирование



#### Сборка

настройки сервера

export JWT\_SECRET=supersecretkey

export DB\_HOST=127.0.0.1

export DB\_PORT=5432

export DB\_NAME=calendar\_db

export DB\_USER=calendar

export DB\_PASS=secret

запуск севрера
./build/calendar\_server
комнада для заупска тестов
ctest --output-on-failure

запуск приложения
./desktop\_app


